% This script comutes the invariants of two images which are translated and
% in-plane rotated copies of each other.
% Tamir Bendory, Dec 2017


close all;
dbstop if error;

n = 20;  %must be even for chebfun
rot_angle = 0; % in-plane rotation
shift = [1,3]; % shift 
zp = max(shift); % zero padding of the image
tic

% loading the example image -- "Cat's Eye Nebula"
rgb = imread('ngc6543a.jpg'); I = rgb2gray(rgb);
I = I(150:450,150:450);
indices = floor(linspace(1,size(I,1),n-zp));
func = zeros(n);
I = double(imresize(I,[n-2*zp,n-2*zp]));
func(zp+1:n-zp,zp+1:n-zp) = I;
func = func/(max(max(func)));

func_rot = imrotate(func,rot_angle,'crop','bicubic');
func_rot = circshift(func_rot,shift);

figure; subplot(121); imshow(func); title('original image');
subplot(122); imshow(func_rot); title('rotated image');

% moving to polar coordinates
theta_dom = linspace(-pi,pi,n);
h = (pi/4)/(n-1); radial_dom = 0:h:(pi/4);
phi = 0:h:2*pi;
[M, K] = meshgrid(theta_dom,radial_dom);
[xx, yy] = pol2cart(M, K);
x = linspace(-.5,.5,n);
y = linspace(-.5,.5,n);
[X,Y] = meshgrid(x,y);
[Az, El] = meshgrid(theta_dom, phi);


ext_func = zeros(size(Az));
ext_func(1:n,1:n) = func;
ext_func_rot = zeros(size(Az));
ext_func_rot(1:n,1:n) = func_rot;

% define the function on the equidistant grid
F = spherefun(ext_func);
F_rot = spherefun(ext_func_rot);

% calculating the coordinates
degree = n; k = 1;
coeffs = zeros((degree+1)^2,3);

SH_matrix = cell(degree+1,1);

for l = 0:degree
    for m = -l:l
        Y = spherefun.sphharm(l,m);
        coeffs(k,1) = sum2(F.*Y);
        coeffs(k,2) = sum2(F_rot.*Y);
        coeffs(k,3:4) = [l m];
        k = k + 1;
    end
    SH_matrix{l+1} = [coeffs(l^2+1:(l+1)^2,1), coeffs(l^2+1:(l+1)^2,2)];
end


%% Computing invariants

% first order invariant (mean)
M1 = SH_matrix{1}(1);
M1_rot = SH_matrix{1}(2);
err1 = abs(M1 - M1_rot)/abs(M1);
disp(strcat('err1 = ',num2str(err1)));

% second-order invariant
M2 = zeros(degree+1,1); M2_rot = M2;
for i = 0:degree
    M2(i+1) =  SH_matrix{i+1}(:,1)'*SH_matrix{i+1}(:,1);
    M2_rot(i+1) =  SH_matrix{i+1}(:,2)'*SH_matrix{i+1}(:,2);
end
err2 = norm(M2 - M2_rot)/norm(M2);
disp(strcat('err2 = ',num2str(err2)));

% third-order invariant
% uploading the table of CGC coefficients up to degree 20
C = load('CGC_table_20'); C = C.C;

% Based on Risi's paper, compute the 4D array g
g = cell(degree+1,degree+1,degree+1);
for l1 = 0: degree
    for l2 = 0: degree
        for l = 0: degree
            g{l1+1,l2+1,l+1} = zeros(2*l+1,1);
            for m=-l:l
                for m1 = -l1:l1
                    if m-m1>l2 || m-m1<-l2 % TB: I am not sure what to do with the m-m1
                        continue;
                    else
                        g{l1+1,l2+1,l+1}(m+l+1) = g{l1+1,l2+1,l+1}(m+l+1) +...
                            C{l1+1,l2+1,l+1}(l1+1+m1,l2+1+m-m1,l+1+m)*SH_matrix{l1+1}(l1+1+m1,1)*SH_matrix{l2+1}(l2+1+m-m1,1);
                    end
                end
            end
        end
    end
end

%The next stage is to compute g{l1,l2,l}'*SH_matrix{l}.
